# Autogenerated from a Treetop grammar. Edits may be lost.


require 'asciidoctor/inline_parser/asciidoctor_link_grammar'
require 'asciidoctor/inline_parser/asciidoctor_email_grammar'
require 'asciidoctor/inline_parser/asciidoctor_passthrough_grammar'
require 'asciidoctor/inline_parser/asciidoctor_image_grammar'
require 'asciidoctor/inline_parser/asciidoctor_kbd_grammar'
require 'asciidoctor/inline_parser/asciidoctor_btn_grammar'
require 'asciidoctor/inline_parser/asciidoctor_menu_grammar'

module AsciidoctorGrammar
  include Treetop::Runtime

  def root
    @root ||= :text
  end

  include AsciidoctorLinkGrammar

  include AsciidoctorEmailGrammar

  include AsciidoctorPassthroughGrammar

  include AsciidoctorImageGrammar

  include AsciidoctorKbdGrammar

  include AsciidoctorBtnGrammar

  include AsciidoctorMenuGrammar

  def _nt_text
    start_index = index
    if node_cache[:text].has_key?(index)
      cached = node_cache[:text][index]
      if cached
        node_cache[:text][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_quoted
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(Text,input, i0...index, s0)

    node_cache[:text][start_index] = r0

    r0
  end

  def _nt_quoted
    start_index = index
    if node_cache[:quoted].has_key?(index)
      cached = node_cache[:quoted][index]
      if cached
        node_cache[:quoted][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_escaped_passthrough_inline_macro
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r1 = r2
      else
        r3 = _nt_escaped_quoted_symbol
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r1 = r3
        else
          r4 = _nt_escaped_role_symbol
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r1 = r4
          else
            r5 = _nt_escaped_explicit_email
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r1 = r5
            else
              r6 = _nt_escaped_implicit_email
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r1 = r6
              else
                r7 = _nt_image
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r1 = r7
                else
                  r8 = _nt_kbd
                  if r8
                    r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                    r1 = r8
                  else
                    r9 = _nt_btn
                    if r9
                      r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                      r1 = r9
                    else
                      r10 = _nt_menu
                      if r10
                        r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                        r1 = r10
                      else
                        r11 = _nt_passthrough_inline_macro
                        if r11
                          r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                          r1 = r11
                        else
                          r12 = _nt_passthrough_triple_plus
                          if r12
                            r12 = SyntaxNode.new(input, (index-1)...index) if r12 == true
                            r1 = r12
                          else
                            r13 = _nt_double_curved_quotes
                            if r13
                              r13 = SyntaxNode.new(input, (index-1)...index) if r13 == true
                              r1 = r13
                            else
                              r14 = _nt_single_curved_quotes
                              if r14
                                r14 = SyntaxNode.new(input, (index-1)...index) if r14 == true
                                r1 = r14
                              else
                                r15 = _nt_literal
                                if r15
                                  r15 = SyntaxNode.new(input, (index-1)...index) if r15 == true
                                  r1 = r15
                                else
                                  r16 = _nt_explicit_link
                                  if r16
                                    r16 = SyntaxNode.new(input, (index-1)...index) if r16 == true
                                    r1 = r16
                                  else
                                    r17 = _nt_explicit_link_protected
                                    if r17
                                      r17 = SyntaxNode.new(input, (index-1)...index) if r17 == true
                                      r1 = r17
                                    else
                                      r18 = _nt_implicit_link
                                      if r18
                                        r18 = SyntaxNode.new(input, (index-1)...index) if r18 == true
                                        r1 = r18
                                      else
                                        r19 = _nt_explicit_email
                                        if r19
                                          r19 = SyntaxNode.new(input, (index-1)...index) if r19 == true
                                          r1 = r19
                                        else
                                          r20 = _nt_implicit_email
                                          if r20
                                            r20 = SyntaxNode.new(input, (index-1)...index) if r20 == true
                                            r1 = r20
                                          else
                                            r21 = _nt_unconstrained_strong
                                            if r21
                                              r21 = SyntaxNode.new(input, (index-1)...index) if r21 == true
                                              r1 = r21
                                            else
                                              r22 = _nt_unconstrained_emphasis
                                              if r22
                                                r22 = SyntaxNode.new(input, (index-1)...index) if r22 == true
                                                r1 = r22
                                              else
                                                r23 = _nt_unconstrained_monospaced
                                                if r23
                                                  r23 = SyntaxNode.new(input, (index-1)...index) if r23 == true
                                                  r1 = r23
                                                else
                                                  r24 = _nt_unconstrained_mark
                                                  if r24
                                                    r24 = SyntaxNode.new(input, (index-1)...index) if r24 == true
                                                    r1 = r24
                                                  else
                                                    r25 = _nt_strong
                                                    if r25
                                                      r25 = SyntaxNode.new(input, (index-1)...index) if r25 == true
                                                      r1 = r25
                                                    else
                                                      r26 = _nt_emphasis
                                                      if r26
                                                        r26 = SyntaxNode.new(input, (index-1)...index) if r26 == true
                                                        r1 = r26
                                                      else
                                                        r27 = _nt_monospaced
                                                        if r27
                                                          r27 = SyntaxNode.new(input, (index-1)...index) if r27 == true
                                                          r1 = r27
                                                        else
                                                          r28 = _nt_mark
                                                          if r28
                                                            r28 = SyntaxNode.new(input, (index-1)...index) if r28 == true
                                                            r1 = r28
                                                          else
                                                            r29 = _nt_superscript
                                                            if r29
                                                              r29 = SyntaxNode.new(input, (index-1)...index) if r29 == true
                                                              r1 = r29
                                                            else
                                                              r30 = _nt_subscript
                                                              if r30
                                                                r30 = SyntaxNode.new(input, (index-1)...index) if r30 == true
                                                                r1 = r30
                                                              else
                                                                if (match_len = has_terminal?(' ', false, index))
                                                                  r31 = true
                                                                  @index += match_len
                                                                else
                                                                  terminal_parse_failure('\' \'')
                                                                  r31 = nil
                                                                end
                                                                if r31
                                                                  r31 = SyntaxNode.new(input, (index-1)...index) if r31 == true
                                                                  r1 = r31
                                                                else
                                                                  r32 = _nt_word
                                                                  if r32
                                                                    r32 = SyntaxNode.new(input, (index-1)...index) if r32 == true
                                                                    r1 = r32
                                                                  else
                                                                    r33 = _nt_symbol
                                                                    if r33
                                                                      r33 = SyntaxNode.new(input, (index-1)...index) if r33 == true
                                                                      r1 = r33
                                                                    else
                                                                      @index = i1
                                                                      r1 = nil
                                                                    end
                                                                  end
                                                                end
                                                              end
                                                            end
                                                          end
                                                        end
                                                      end
                                                    end
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(Expression,input, i0...index, s0)
    end

    node_cache[:quoted][start_index] = r0

    r0
  end

  module DoubleCurvedQuotes0
    def double_curved_quotes_content
      elements[1]
    end

  end

  def _nt_double_curved_quotes
    start_index = index
    if node_cache[:double_curved_quotes].has_key?(index)
      cached = node_cache[:double_curved_quotes][index]
      if cached
        node_cache[:double_curved_quotes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('"`', false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'"`\'')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_double_curved_quotes_content
      s0 << r2
      if r2
        if (match_len = has_terminal?('`"', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'`"\'')
          r3 = nil
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(DoubleCurvedQuoted,input, i0...index, s0)
      r0.extend(DoubleCurvedQuotes0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:double_curved_quotes][start_index] = r0

    r0
  end

  def _nt_double_curved_quotes_content
    start_index = index
    if node_cache[:double_curved_quotes_content].has_key?(index)
      cached = node_cache[:double_curved_quotes_content][index]
      if cached
        node_cache[:double_curved_quotes_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[^`"]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[^`"]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:double_curved_quotes_content][start_index] = r0

    r0
  end

  module SingleCurvedQuotes0
    def single_curved_quotes_content
      elements[1]
    end

  end

  def _nt_single_curved_quotes
    start_index = index
    if node_cache[:single_curved_quotes].has_key?(index)
      cached = node_cache[:single_curved_quotes][index]
      if cached
        node_cache[:single_curved_quotes][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('\'`', false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'\\\'`\'')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_single_curved_quotes_content
      s0 << r2
      if r2
        if (match_len = has_terminal?('`\'', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'`\\\'\'')
          r3 = nil
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SingleCurvedQuoted,input, i0...index, s0)
      r0.extend(SingleCurvedQuotes0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:single_curved_quotes][start_index] = r0

    r0
  end

  def _nt_single_curved_quotes_content
    start_index = index
    if node_cache[:single_curved_quotes_content].has_key?(index)
      cached = node_cache[:single_curved_quotes_content][index]
      if cached
        node_cache[:single_curved_quotes_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[^`\\\']'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[^`\\\']')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:single_curved_quotes_content][start_index] = r0

    r0
  end

  module Literal0
    def literal_content
      elements[2]
    end

  end

  def _nt_literal
    start_index = index
    if node_cache[:literal].has_key?(index)
      cached = node_cache[:literal][index]
      if cached
        node_cache[:literal][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('+', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('\'+\'')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      r3 = _nt_spaces
      if r3
        @index = i2
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_literal_content
        s0 << r4
        if r4
          i5 = index
          r6 = _nt_spaces
          if r6
            @index = i5
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            if (match_len = has_terminal?('+', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('\'+\'')
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Literal,input, i0...index, s0)
      r0.extend(Literal0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:literal][start_index] = r0

    r0
  end

  def _nt_literal_content
    start_index = index
    if node_cache[:literal_content].has_key?(index)
      cached = node_cache[:literal_content][index]
      if cached
        node_cache[:literal_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[^+]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[^+]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:literal_content][start_index] = r0

    r0
  end

  module Strong0
    def strong_content
      elements[3]
    end

  end

  def _nt_strong
    start_index = index
    if node_cache[:strong].has_key?(index)
      cached = node_cache[:strong][index]
      if cached
        node_cache[:strong][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('*', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'*\'')
        r3 = nil
      end
      s0 << r3
      if r3
        i4 = index
        r5 = _nt_spaces
        if r5
          @index = i4
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_strong_content
          s0 << r6
          if r6
            i7 = index
            r8 = _nt_spaces
            if r8
              @index = i7
              r7 = nil
            else
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              if (match_len = has_terminal?('*', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('\'*\'')
                r9 = nil
              end
              s0 << r9
              if r9
                i10 = index
                r11 = _nt_constrained_mark_exception_end
                if r11
                  @index = i10
                  r10 = nil
                else
                  @index = i10
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StrongQuoted,input, i0...index, s0)
      r0.extend(Strong0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:strong][start_index] = r0

    r0
  end

  module UnconstrainedStrong0
    def strong_content
      elements[2]
    end

  end

  def _nt_unconstrained_strong
    start_index = index
    if node_cache[:unconstrained_strong].has_key?(index)
      cached = node_cache[:unconstrained_strong][index]
      if cached
        node_cache[:unconstrained_strong][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('**', false, index))
        r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'**\'')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_strong_content
        s0 << r4
        if r4
          if (match_len = has_terminal?('**', false, index))
            r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'**\'')
            r5 = nil
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StrongQuoted,input, i0...index, s0)
      r0.extend(UnconstrainedStrong0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:unconstrained_strong][start_index] = r0

    r0
  end

  def _nt_strong_content
    start_index = index
    if node_cache[:strong_content].has_key?(index)
      cached = node_cache[:strong_content][index]
      if cached
        node_cache[:strong_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_strong_content_greedy
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:strong_content][start_index] = r0

    r0
  end

  module StrongContentGreedy0
    def constrained_mark_exception
      elements[1]
    end
  end

  def _nt_strong_content_greedy
    start_index = index
    if node_cache[:strong_content_greedy].has_key?(index)
      cached = node_cache[:strong_content_greedy][index]
      if cached
        node_cache[:strong_content_greedy][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(@regexps[gr = '\A[^*]'] ||= Regexp.new(gr), :regexp, index)
      r1 = true
      @index += 1
    else
      terminal_parse_failure('[^*]')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      i2, s2 = index, []
      if (match_len = has_terminal?('*', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'*\'')
        r3 = nil
      end
      s2 << r3
      if r3
        r4 = _nt_constrained_mark_exception
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(StrongContentGreedy0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:strong_content_greedy][start_index] = r0

    r0
  end

  module Emphasis0
    def emphasis_content
      elements[3]
    end

  end

  def _nt_emphasis
    start_index = index
    if node_cache[:emphasis].has_key?(index)
      cached = node_cache[:emphasis][index]
      if cached
        node_cache[:emphasis][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('_', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'_\'')
        r3 = nil
      end
      s0 << r3
      if r3
        i4 = index
        r5 = _nt_spaces
        if r5
          @index = i4
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_emphasis_content
          s0 << r6
          if r6
            i7 = index
            r8 = _nt_spaces
            if r8
              @index = i7
              r7 = nil
            else
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              if (match_len = has_terminal?('_', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('\'_\'')
                r9 = nil
              end
              s0 << r9
              if r9
                i10 = index
                r11 = _nt_constrained_mark_exception_end
                if r11
                  @index = i10
                  r10 = nil
                else
                  @index = i10
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(EmphasisQuoted,input, i0...index, s0)
      r0.extend(Emphasis0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:emphasis][start_index] = r0

    r0
  end

  module UnconstrainedEmphasis0
    def emphasis_content
      elements[2]
    end

  end

  def _nt_unconstrained_emphasis
    start_index = index
    if node_cache[:unconstrained_emphasis].has_key?(index)
      cached = node_cache[:unconstrained_emphasis][index]
      if cached
        node_cache[:unconstrained_emphasis][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('__', false, index))
        r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'__\'')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_emphasis_content
        s0 << r4
        if r4
          if (match_len = has_terminal?('__', false, index))
            r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'__\'')
            r5 = nil
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(EmphasisQuoted,input, i0...index, s0)
      r0.extend(UnconstrainedEmphasis0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:unconstrained_emphasis][start_index] = r0

    r0
  end

  def _nt_emphasis_content
    start_index = index
    if node_cache[:emphasis_content].has_key?(index)
      cached = node_cache[:emphasis_content][index]
      if cached
        node_cache[:emphasis_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_emphasis_content_greedy
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:emphasis_content][start_index] = r0

    r0
  end

  module EmphasisContentGreedy0
    def constrained_mark_exception
      elements[1]
    end
  end

  def _nt_emphasis_content_greedy
    start_index = index
    if node_cache[:emphasis_content_greedy].has_key?(index)
      cached = node_cache[:emphasis_content_greedy][index]
      if cached
        node_cache[:emphasis_content_greedy][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(@regexps[gr = '\A[^_]'] ||= Regexp.new(gr), :regexp, index)
      r1 = true
      @index += 1
    else
      terminal_parse_failure('[^_]')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      i2, s2 = index, []
      if (match_len = has_terminal?('_', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'_\'')
        r3 = nil
      end
      s2 << r3
      if r3
        r4 = _nt_constrained_mark_exception
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(EmphasisContentGreedy0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:emphasis_content_greedy][start_index] = r0

    r0
  end

  module Monospaced0
    def monospaced_content
      elements[3]
    end

  end

  def _nt_monospaced
    start_index = index
    if node_cache[:monospaced].has_key?(index)
      cached = node_cache[:monospaced][index]
      if cached
        node_cache[:monospaced][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('`', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'`\'')
        r3 = nil
      end
      s0 << r3
      if r3
        i4 = index
        r5 = _nt_spaces
        if r5
          @index = i4
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_monospaced_content
          s0 << r6
          if r6
            i7 = index
            r8 = _nt_spaces
            if r8
              @index = i7
              r7 = nil
            else
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              if (match_len = has_terminal?('`', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('\'`\'')
                r9 = nil
              end
              s0 << r9
              if r9
                i10 = index
                r11 = _nt_constrained_mark_exception_end
                if r11
                  @index = i10
                  r10 = nil
                else
                  @index = i10
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(MonospacedQuoted,input, i0...index, s0)
      r0.extend(Monospaced0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:monospaced][start_index] = r0

    r0
  end

  module UnconstrainedMonospaced0
    def monospaced_content
      elements[2]
    end

  end

  def _nt_unconstrained_monospaced
    start_index = index
    if node_cache[:unconstrained_monospaced].has_key?(index)
      cached = node_cache[:unconstrained_monospaced][index]
      if cached
        node_cache[:unconstrained_monospaced][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('``', false, index))
        r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'``\'')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_monospaced_content
        s0 << r4
        if r4
          if (match_len = has_terminal?('``', false, index))
            r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'``\'')
            r5 = nil
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(MonospacedQuoted,input, i0...index, s0)
      r0.extend(UnconstrainedMonospaced0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:unconstrained_monospaced][start_index] = r0

    r0
  end

  def _nt_monospaced_content
    start_index = index
    if node_cache[:monospaced_content].has_key?(index)
      cached = node_cache[:monospaced_content][index]
      if cached
        node_cache[:monospaced_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_monospaced_content_greedy
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:monospaced_content][start_index] = r0

    r0
  end

  module MonospacedContentGreedy0
    def constrained_mark_exception
      elements[1]
    end
  end

  def _nt_monospaced_content_greedy
    start_index = index
    if node_cache[:monospaced_content_greedy].has_key?(index)
      cached = node_cache[:monospaced_content_greedy][index]
      if cached
        node_cache[:monospaced_content_greedy][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(@regexps[gr = '\A[^`]'] ||= Regexp.new(gr), :regexp, index)
      r1 = true
      @index += 1
    else
      terminal_parse_failure('[^`]')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      i2, s2 = index, []
      if (match_len = has_terminal?('`', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'`\'')
        r3 = nil
      end
      s2 << r3
      if r3
        r4 = _nt_constrained_mark_exception
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(MonospacedContentGreedy0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:monospaced_content_greedy][start_index] = r0

    r0
  end

  module Mark0
    def mark_content
      elements[3]
    end

  end

  def _nt_mark
    start_index = index
    if node_cache[:mark].has_key?(index)
      cached = node_cache[:mark][index]
      if cached
        node_cache[:mark][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('#', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'#\'')
        r3 = nil
      end
      s0 << r3
      if r3
        i4 = index
        r5 = _nt_spaces
        if r5
          @index = i4
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_mark_content
          s0 << r6
          if r6
            i7 = index
            r8 = _nt_spaces
            if r8
              @index = i7
              r7 = nil
            else
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              if (match_len = has_terminal?('#', false, index))
                r9 = true
                @index += match_len
              else
                terminal_parse_failure('\'#\'')
                r9 = nil
              end
              s0 << r9
              if r9
                i10 = index
                r11 = _nt_constrained_mark_exception_end
                if r11
                  @index = i10
                  r10 = nil
                else
                  @index = i10
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(MarkQuoted,input, i0...index, s0)
      r0.extend(Mark0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:mark][start_index] = r0

    r0
  end

  module UnconstrainedMark0
    def mark_content
      elements[2]
    end

  end

  def _nt_unconstrained_mark
    start_index = index
    if node_cache[:unconstrained_mark].has_key?(index)
      cached = node_cache[:unconstrained_mark][index]
      if cached
        node_cache[:unconstrained_mark][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_quoted_text_attrs
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if (match_len = has_terminal?('##', false, index))
        r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'##\'')
        r3 = nil
      end
      s0 << r3
      if r3
        r4 = _nt_mark_content
        s0 << r4
        if r4
          if (match_len = has_terminal?('##', false, index))
            r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'##\'')
            r5 = nil
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(MarkQuoted,input, i0...index, s0)
      r0.extend(UnconstrainedMark0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:unconstrained_mark][start_index] = r0

    r0
  end

  def _nt_mark_content
    start_index = index
    if node_cache[:mark_content].has_key?(index)
      cached = node_cache[:mark_content][index]
      if cached
        node_cache[:mark_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_mark_content_greedy
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:mark_content][start_index] = r0

    r0
  end

  module MarkContentGreedy0
    def constrained_mark_exception
      elements[1]
    end
  end

  def _nt_mark_content_greedy
    start_index = index
    if node_cache[:mark_content_greedy].has_key?(index)
      cached = node_cache[:mark_content_greedy][index]
      if cached
        node_cache[:mark_content_greedy][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(@regexps[gr = '\A[^#]'] ||= Regexp.new(gr), :regexp, index)
      r1 = true
      @index += 1
    else
      terminal_parse_failure('[^#]')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      i2, s2 = index, []
      if (match_len = has_terminal?('#', false, index))
        r3 = true
        @index += match_len
      else
        terminal_parse_failure('\'#\'')
        r3 = nil
      end
      s2 << r3
      if r3
        r4 = _nt_constrained_mark_exception
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        r2.extend(MarkContentGreedy0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:mark_content_greedy][start_index] = r0

    r0
  end

  module Superscript0
    def superscript_content
      elements[2]
    end

  end

  def _nt_superscript
    start_index = index
    if node_cache[:superscript].has_key?(index)
      cached = node_cache[:superscript][index]
      if cached
        node_cache[:superscript][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('^', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('\'^\'')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      r3 = _nt_spaces
      if r3
        @index = i2
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_superscript_content
        s0 << r4
        if r4
          i5 = index
          r6 = _nt_spaces
          if r6
            @index = i5
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            if (match_len = has_terminal?('^', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('\'^\'')
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SuperscriptQuoted,input, i0...index, s0)
      r0.extend(Superscript0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:superscript][start_index] = r0

    r0
  end

  def _nt_superscript_content
    start_index = index
    if node_cache[:superscript_content].has_key?(index)
      cached = node_cache[:superscript_content][index]
      if cached
        node_cache[:superscript_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[^\\^]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[^\\^]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:superscript_content][start_index] = r0

    r0
  end

  module Subscript0
    def subscript_content
      elements[2]
    end

  end

  def _nt_subscript
    start_index = index
    if node_cache[:subscript].has_key?(index)
      cached = node_cache[:subscript][index]
      if cached
        node_cache[:subscript][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('~', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('\'~\'')
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      r3 = _nt_spaces
      if r3
        @index = i2
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_subscript_content
        s0 << r4
        if r4
          i5 = index
          r6 = _nt_spaces
          if r6
            @index = i5
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            if (match_len = has_terminal?('~', false, index))
              r7 = true
              @index += match_len
            else
              terminal_parse_failure('\'~\'')
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SubscriptQuoted,input, i0...index, s0)
      r0.extend(Subscript0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:subscript][start_index] = r0

    r0
  end

  def _nt_subscript_content
    start_index = index
    if node_cache[:subscript_content].has_key?(index)
      cached = node_cache[:subscript_content][index]
      if cached
        node_cache[:subscript_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[^~]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[^~]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(QuotedContent,input, i0...index, s0)
    end

    node_cache[:subscript_content][start_index] = r0

    r0
  end

  module QuotedTextAttrs0
    def quoted_text_attrs_content
      elements[1]
    end

  end

  def _nt_quoted_text_attrs
    start_index = index
    if node_cache[:quoted_text_attrs].has_key?(index)
      cached = node_cache[:quoted_text_attrs][index]
      if cached
        node_cache[:quoted_text_attrs][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('[', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('\'[\'')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_quoted_text_attrs_content
      s0 << r2
      if r2
        if (match_len = has_terminal?(']', false, index))
          r3 = true
          @index += match_len
        else
          terminal_parse_failure('\']\'')
          r3 = nil
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(QuotedTextAttributes,input, i0...index, s0)
      r0.extend(QuotedTextAttrs0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:quoted_text_attrs][start_index] = r0

    r0
  end

  def _nt_quoted_text_attrs_content
    start_index = index
    if node_cache[:quoted_text_attrs_content].has_key?(index)
      cached = node_cache[:quoted_text_attrs_content][index]
      if cached
        node_cache[:quoted_text_attrs_content][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_quoted_text_anchor
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r1 = r2
      else
        r3 = _nt_quoted_text_role
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(QuotedTextAttributesContent,input, i0...index, s0)

    node_cache[:quoted_text_attrs_content][start_index] = r0

    r0
  end

  module QuotedTextRole0
    def role_identifier
      elements[1]
    end
  end

  def _nt_quoted_text_role
    start_index = index
    if node_cache[:quoted_text_role].has_key?(index)
      cached = node_cache[:quoted_text_role][index]
      if cached
        node_cache[:quoted_text_role][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('.', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('\'.\'')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_role_identifier
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(QuotedTextRole,input, i0...index, s0)
      r0.extend(QuotedTextRole0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:quoted_text_role][start_index] = r0

    r0
  end

  module QuotedTextAnchor0
    def anchor_identifier
      elements[1]
    end
  end

  def _nt_quoted_text_anchor
    start_index = index
    if node_cache[:quoted_text_anchor].has_key?(index)
      cached = node_cache[:quoted_text_anchor][index]
      if cached
        node_cache[:quoted_text_anchor][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if (match_len = has_terminal?('#', false, index))
      r1 = true
      @index += match_len
    else
      terminal_parse_failure('\'#\'')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_anchor_identifier
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(QuotedTextAnchor,input, i0...index, s0)
      r0.extend(QuotedTextAnchor0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:quoted_text_anchor][start_index] = r0

    r0
  end

  def _nt_constrained_mark_exception_end
    start_index = index
    if node_cache[:constrained_mark_exception_end].has_key?(index)
      cached = node_cache[:constrained_mark_exception_end][index]
      if cached
        node_cache[:constrained_mark_exception_end][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_constrained_mark_exception

    node_cache[:constrained_mark_exception_end][start_index] = r0

    r0
  end

  def _nt_constrained_mark_exception
    start_index = index
    if node_cache[:constrained_mark_exception].has_key?(index)
      cached = node_cache[:constrained_mark_exception][index]
      if cached
        node_cache[:constrained_mark_exception][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?(@regexps['__r__'+(gr = "\\A[\\p{Word}&&[^_]]")] ||= Regexp.new(gr, 0), :regexp, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'[\\p{Word}&&[^_]]\'')
      r0 = nil
    end

    node_cache[:constrained_mark_exception][start_index] = r0

    r0
  end

  def _nt_escaped_quoted_symbol
    start_index = index
    if node_cache[:escaped_quoted_symbol].has_key?(index)
      cached = node_cache[:escaped_quoted_symbol][index]
      if cached
        node_cache[:escaped_quoted_symbol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if (match_len = has_terminal?('\*', false, index))
      r1 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'\\*\'')
      r1 = nil
    end
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      if (match_len = has_terminal?('\_', false, index))
        r2 = instantiate_node(SyntaxNode,input, index...(index + match_len))
        @index += match_len
      else
        terminal_parse_failure('\'\\_\'')
        r2 = nil
      end
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        if (match_len = has_terminal?('\`', false, index))
          r3 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'\\`\'')
          r3 = nil
        end
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          if (match_len = has_terminal?('\#', false, index))
            r4 = instantiate_node(SyntaxNode,input, index...(index + match_len))
            @index += match_len
          else
            terminal_parse_failure('\'\\#\'')
            r4 = nil
          end
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            if (match_len = has_terminal?('\^', false, index))
              r5 = instantiate_node(SyntaxNode,input, index...(index + match_len))
              @index += match_len
            else
              terminal_parse_failure('\'\\^\'')
              r5 = nil
            end
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              if (match_len = has_terminal?('\~', false, index))
                r6 = instantiate_node(SyntaxNode,input, index...(index + match_len))
                @index += match_len
              else
                terminal_parse_failure('\'\\~\'')
                r6 = nil
              end
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:escaped_quoted_symbol][start_index] = r0

    r0
  end

  def _nt_escaped_role_symbol
    start_index = index
    if node_cache[:escaped_role_symbol].has_key?(index)
      cached = node_cache[:escaped_role_symbol][index]
      if cached
        node_cache[:escaped_role_symbol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if (match_len = has_terminal?('\[', false, index))
      r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
      @index += match_len
    else
      terminal_parse_failure('\'\\[\'')
      r0 = nil
    end

    node_cache[:escaped_role_symbol][start_index] = r0

    r0
  end

  def _nt_symbol
    start_index = index
    if node_cache[:symbol].has_key?(index)
      cached = node_cache[:symbol][index]
      if cached
        node_cache[:symbol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_symbol_basic
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_quoted_symbol
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:symbol][start_index] = r0

    r0
  end

  def _nt_symbol_basic
    start_index = index
    if node_cache[:symbol_basic].has_key?(index)
      cached = node_cache[:symbol_basic][index]
      if cached
        node_cache[:symbol_basic][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[&\\-:;=,"\'\\.!\\\\{}\\]\\[<>/()]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[&\\-:;=,"\'\\.!\\\\{}\\]\\[<>/()]')
      r0 = nil
    end

    node_cache[:symbol_basic][start_index] = r0

    r0
  end

  def _nt_quoted_symbol
    start_index = index
    if node_cache[:quoted_symbol].has_key?(index)
      cached = node_cache[:quoted_symbol][index]
      if cached
        node_cache[:quoted_symbol][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[_*#`^~]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[_*#`^~]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:quoted_symbol][start_index] = r0

    r0
  end

  def _nt_role_identifier
    start_index = index
    if node_cache[:role_identifier].has_key?(index)
      cached = node_cache[:role_identifier][index]
      if cached
        node_cache[:role_identifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_identifier
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(RoleIdentifier,input, i0...index, s0)
    end

    node_cache[:role_identifier][start_index] = r0

    r0
  end

  def _nt_anchor_identifier
    start_index = index
    if node_cache[:anchor_identifier].has_key?(index)
      cached = node_cache[:anchor_identifier][index]
      if cached
        node_cache[:anchor_identifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_identifier
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(AnchorIdentifier,input, i0...index, s0)
    end

    node_cache[:anchor_identifier][start_index] = r0

    r0
  end

  def _nt_identifier
    start_index = index
    if node_cache[:identifier].has_key?(index)
      cached = node_cache[:identifier][index]
      if cached
        node_cache[:identifier][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[0-9a-zA-Z_\\-]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure('[0-9a-zA-Z_\\-]')
      r0 = nil
    end

    node_cache[:identifier][start_index] = r0

    r0
  end

  def _nt_word
    start_index = index
    if node_cache[:word].has_key?(index)
      cached = node_cache[:word][index]
      if cached
        node_cache[:word][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_alnum

    node_cache[:word][start_index] = r0

    r0
  end

  def _nt_number
    start_index = index
    if node_cache[:number].has_key?(index)
      cached = node_cache[:number][index]
      if cached
        node_cache[:number][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[0-9]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:number][start_index] = r0

    r0
  end

  def _nt_alpha
    start_index = index
    if node_cache[:alpha].has_key?(index)
      cached = node_cache[:alpha][index]
      if cached
        node_cache[:alpha][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[a-zA-Z]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[a-zA-Z]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:alpha][start_index] = r0

    r0
  end

  def _nt_alnum
    start_index = index
    if node_cache[:alnum].has_key?(index)
      cached = node_cache[:alnum][index]
      if cached
        node_cache[:alnum][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_number
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_alpha
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:alnum][start_index] = r0

    r0
  end

  def _nt_spaces
    start_index = index
    if node_cache[:spaces].has_key?(index)
      cached = node_cache[:spaces][index]
      if cached
        node_cache[:spaces][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      if has_terminal?(@regexps[gr = '\A[ ]'] ||= Regexp.new(gr), :regexp, index)
        r1 = true
        @index += 1
      else
        terminal_parse_failure('[ ]')
        r1 = nil
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
    end

    node_cache[:spaces][start_index] = r0

    r0
  end

end

class AsciidoctorGrammarParser < Treetop::Runtime::CompiledParser
  include AsciidoctorGrammar
end

